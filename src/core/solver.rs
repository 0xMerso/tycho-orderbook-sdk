use rayon::iter::{IndexedParallelIterator, IntoParallelRefIterator, ParallelIterator};
use tokio::time::Instant;

use crate::{
    data::fmt::SrzToken,
    maths::{self},
    types::{ProtoSimComp, TradeResult},
    utils::{self, r#static::maths::ONE_HD},
};

pub trait OrderbookSolver: Send + Sync {
    fn generate_steps(&self, liquidity: f64) -> Vec<f64>;
    /// Protosims contains the required functions to get the amount out of a swap
    #[allow(clippy::too_many_arguments)]
    fn optimize(&self, protosims: &[ProtoSimComp], steps: Vec<f64>, eth_usd: f64, gas_price: u128, from: &SrzToken, to: &SrzToken, price_from_to: f64, output_eth_worth: f64) -> Vec<TradeResult>;
}

// Default implementation

pub struct DefaultOrderbookSolver;

impl OrderbookSolver for DefaultOrderbookSolver {
    fn generate_steps(&self, liquidity: f64) -> Vec<f64> {
        exponential(liquidity)
    }

    #[allow(clippy::too_many_arguments)]
    fn optimize(&self, protosim: &[ProtoSimComp], steps: Vec<f64>, eth_usd: f64, gas_price: u128, from: &SrzToken, to: &SrzToken, price_from_to: f64, output_eth_worth: f64) -> Vec<TradeResult> {
        tracing::debug!("Default solver: optimize called with steps: {:?}", steps);
        optimize(protosim, steps, eth_usd, gas_price, from, to, price_from_to, output_eth_worth)
    }
}

pub struct CustomOrderbookSolver;

impl OrderbookSolver for CustomOrderbookSolver {
    fn generate_steps(&self, liquidity: f64) -> Vec<f64> {
        exponential(liquidity)
    }

    #[allow(clippy::too_many_arguments)]
    fn optimize(&self, protosim: &[ProtoSimComp], steps: Vec<f64>, eth_usd: f64, gas_price: u128, from: &SrzToken, to: &SrzToken, price_from_to: f64, output_eth_worth: f64) -> Vec<TradeResult> {
        // For custom logic, take the last available step if present.
        tracing::debug!("Custom solver: optimize called with steps: {:?}", steps);
        optimize(protosim, steps, eth_usd, gas_price, from, to, price_from_to, output_eth_worth)
    }
}

// Executes the optimizer for a given token pair and a set of pools.
/// Use the steps generated by function pointer
use std::panic::{self, AssertUnwindSafe};

#[allow(clippy::too_many_arguments)]
pub fn optimize(protosim: &[ProtoSimComp], steps: Vec<f64>, eth_usd: f64, gas_price: u128, from: &SrzToken, to: &SrzToken, spot_price: f64, output_eth_worth: f64) -> Vec<TradeResult> {
    let trades: Vec<Option<TradeResult>> = steps
        //.iter()
        .par_iter()
        .enumerate()
        .map(|(x, amount)| {
            let res = panic::catch_unwind(AssertUnwindSafe(|| {
                let tmstp = Instant::now();
                let result = maths::opti::gradient(*amount, protosim, from.clone(), to.clone(), eth_usd, gas_price, spot_price, output_eth_worth);
                let elapsed = tmstp.elapsed().as_millis();
                let gas_cost: f64 = result.gas_costs_usd.iter().sum();
                // let sum_distribution: f64 = result.distribution.iter().sum();
                // let sum_distributed: f64 = result.distributed.iter().sum();
                tracing::trace!(
                    " - #{:<2} | In: {:.7} {}, Out: {:.7} {} at avg price {:.7} (vs spot_price {:.7}) | Price impact %: {:.4} | Gas cost {:.5}$ | Took: {} ms",
                    x,
                    result.amount,
                    from.symbol,
                    result.output,
                    to.symbol,
                    result.average_sell_price,
                    spot_price,
                    result.price_impact * ONE_HD,
                    gas_cost,
                    elapsed
                );
                result
            }));
            match res {
                Ok(trade_result) => Some(trade_result),
                Err(e) => {
                    tracing::error!("Task {} panicked: {:?}", x, e);
                    None
                }
            }
        })
        .collect();
    // Filter out any None values.
    let trades: Vec<TradeResult> = trades.into_iter().flatten().collect();
    // Remove trades that have a non-increasing price impact.
    let size = trades.len();
    // let (filtered_trades, removed) = remove_decreasing_price(&trades); // [old]
    let (filtered_trades, removed) = remove_decreasing_price_with_sensitivity(&trades, 0.05); // [new]

    tracing::debug!("Removed {} out of {} trades with decreasing price.", removed, size);
    filtered_trades
}

/// Default steps function
/// This function generates a set of quoted amounts based on the aggregated liquidity of the pools.
/// Up to END_MULTIPLIER % of the aggregated liquidity, it generates a set of amounts using an exponential function with minimum delta percentage.
pub fn exponential(liquidity: f64) -> Vec<f64> {
    let start = liquidity / utils::r#static::maths::TEN_MILLIONS;
    let steps = maths::steps::expo(
        utils::r#static::maths::simu::COUNT,
        utils::r#static::maths::simu::START_MULTIPLIER,
        utils::r#static::maths::simu::END_MULTIPLIER,
        utils::r#static::maths::simu::END_MULTIPLIER * utils::r#static::maths::simu::MIN_EXP_DELTA_PCT,
    );
    let steps = steps.iter().map(|x| x * start).collect::<Vec<f64>>();
    let r8 = steps.iter().map(|x| (x * 100_000_000.0).round() / 100_000_000.0).collect::<Vec<f64>>();
    r8
}
/// Retains only those trades whose average_sell_price does not drop more than `max_drop_pct`
/// relative to the previous kept trade. Returns (filtered, removed_count).
pub fn remove_decreasing_price_with_sensitivity(
    items: &[TradeResult],
    max_drop_pct: f64, // e.g. 0.05 for 5%
) -> (Vec<TradeResult>, usize) {
    if items.is_empty() {
        return (Vec::new(), 0);
    }

    let mut filtered = Vec::with_capacity(items.len());
    // start with first trade unconditionally
    let mut last_kept_price = items[0].average_sell_price;
    filtered.push(items[0].clone());

    for trade in &items[1..] {
        let price = trade.average_sell_price;
        // compute relative drop: (previous – current) / previous
        let drop_ratio = (last_kept_price - price) / last_kept_price;
        // keep trade only if drop ≤ threshold
        if drop_ratio <= max_drop_pct {
            filtered.push(trade.clone());
            last_kept_price = price;
        }
    }

    let removed = items.len() - filtered.len();
    (filtered, removed)
}
